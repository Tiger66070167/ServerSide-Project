const taskModel = require('../models/taskModel');
const userModel = require('../models/userModel');
const categoryModel = require('../models/categoryModel')
const subtaskModel = require('../models/subtaskModel');

/* =================================
   TASK CONTROLLER METHODS
   ================================= */
exports.showTasks = async (req, res) => {
  try {
    const user = await userModel.findById(req.cookies.user_id);

    if (!user) {
      res.clearCookie('user_id');
      return res.redirect('/login');
    }

    const filter = req.query.status || 'All';
    const category_id = req.query.category_id || null;
    const sort = req.query.sort || null;

    const tasks = await taskModel.getFilteredAndSortedTasks(filter, category_id, sort, user.user_id);
    const categories = await categoryModel.getCategoriesByUser(user.user_id);

    res.render('index', { tasks, user: user, username: user.username, filter, categories, category_id, sort, currentPath: '/' });
  } catch (err) {
    console.error("Error in showTasks:", err);
    res.redirect('/login');
  }
};

exports.showCreateForm = async (req, res) => {
  const user_id = req.cookies.user_id;
  const categories = await categoryModel.getCategoriesByUser(user_id);
  res.render('pop-up/create', { categories });
};

exports.createTask = async (req, res) => {
  try {
    const { title, description, due_date, priority, category_id } = req.body;
    const user_id = req.cookies.user_id;

    const newTaskId = await taskModel.createTask({
      title,
      description,
      due_date: due_date || null,
      priority,
      status: 'Pending', // Default status
      category_id: category_id || null,
      user_id
    });
    
    const createdTask = await taskModel.getTaskById(newTaskId);

    res.status(201).json(createdTask);

  } catch (error) {
    // üéØ --- THIS IS THE CRITICAL FIX --- üéØ
    // Check for the specific MySQL error code for a foreign key violation
    if (error.code === 'ER_NO_REFERENCED_ROW_2') {
      return res.status(400).json({ error: 'Invalid category_id: This category does not exist.' });
    }
    
    // For any other errors, log them and return a generic 500 error
    console.error('Error creating task:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

exports.showEditForm = async (req, res) => {
  const user_id = req.cookies.user_id;
  const task_id = req.params.id;

  const task = await taskModel.getTaskById(task_id);
  const categories = await categoryModel.getCategoriesByUser(user_id);

  if (!task) return res.send('Task not found');

  res.render('pop-up/edit', { task, categories });
};

exports.updateTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    const currentTask = await taskModel.getTaskById(taskId);

    if (!currentTask) {
      return res.status(404).json({ error: 'Task not found' });
    }

    const updatedData = {
      title: req.body.title || currentTask.title,
      description: req.body.description || currentTask.description,
      due_date: req.body.due_date || currentTask.due_date,
      priority: req.body.priority || currentTask.priority,
      status: req.body.status || currentTask.status,
      category_id: req.body.hasOwnProperty('category_id') 
                   ? req.body.category_id 
                   : currentTask.category_id,
    };

    await taskModel.updateTask(taskId, updatedData);
    
    // Always return JSON for the API
    const newlyUpdatedTask = await taskModel.getTaskById(taskId);
    res.status(200).json(newlyUpdatedTask);

  } catch (error) {
    if (error.code === 'ER_NO_REFERENCED_ROW_2') {
      return res.status(400).json({ error: 'Invalid category_id: This category does not exist.' });
    }
    console.error("Error updating task:", error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

exports.deleteTask = async (req, res) => {
  await taskModel.deleteTask(req.params.id);
  res.status(200).json({ message: `Task ${req.params.id} has been permanently deleted.` });
};

exports.softDeleteTask = async (req, res) => {
  await taskModel.softDeleteTask(req.params.id);
  res.status(200).json({ message: `Task ${req.params.id} moved to archive.` });
};

exports.viewarchive = async (req, res) => {
  const tasks = await taskModel.getDeletedTasks();
  try {
    if (req.cookies.user_id) {
        const user = await userModel.findById(req.cookies.user_id);
        if (user) {
            username = user.username;
        }
    }

  res.render('archive', { tasks, username, currentPath: '/archive' });

  } catch (err) {
    console.error("Error rendering archive page:", err.message);
    res.redirect('/');
  }
};

exports.recoverTask = async (req, res) =>{
  await taskModel.recoverTask(req.params.id);
  res.status(200).json({ message: `Task ${req.params.id} has been recovered.` });
};
// -----------------------------------------------------------

/* =================================
   SUBTASK CONTROLLER METHODS
   ================================= */

// 1. ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î Task ‡πÅ‡∏•‡∏∞ Subtasks
exports.showKanbanBoard = async (req, res) => {
  try {
    const taskId = req.params.id;
    const user = await userModel.findById(req.cookies.user_id);

    if (!user) {
      return res.redirect('/login');
    }

    // ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è
    const [task, lists, categories] = await Promise.all([
      taskModel.getTaskById(taskId),
      subtaskModel.getListsByTaskId(taskId),
      categoryModel.getCategoriesByUser(user.user_id) // <-- ‡∏î‡∏∂‡∏á Categories ‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢
    ]);

    if (!task) {
      return res.status(404).send('Task not found');
    }

    const listsWithCards = await Promise.all(
      lists.map(async (list) => {
        const cards = await subtaskModel.getCardsByListId(list.list_id);
        return { ...list, cards: cards };
      })
    );

    // ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è 2. ‡∏™‡πà‡∏á categories ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô res.render ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è
    res.render('kanban', {
      task,
      lists: listsWithCards,
      categories, // <-- ‡∏™‡πà‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ categories ‡πÑ‡∏õ‡πÉ‡∏´‡πâ EJS
      username: user.username,
      currentPath: '/kanban'
    });

  } catch (err) {
    console.error("Error showing Kanban board:", err.message);
    res.redirect('/');
  }
};

// 2. ‡∏™‡∏£‡πâ‡∏≤‡∏á List ‡πÉ‡∏´‡∏°‡πà
exports.createList = async (req, res) => {
  try {
    const taskId = req.params.id;
    const { title } = req.body;

    if (!title) {
      return res.status(400).json({ error: 'Title is required' });
    }
    
    const existingLists = await subtaskModel.getListsByTaskId(taskId);
    if (existingLists.length === 0) {
        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ List ‡πÄ‡∏•‡∏¢ (‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠ List ‡πÅ‡∏£‡∏Å) ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Task
        await taskModel.updateTaskStatus(taskId, 'In Progress');
    }

    // ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç model ‡πÉ‡∏´‡πâ return list ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢
    const newList = await subtaskModel.createList(title, taskId);

    // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞ redirect, ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô JSON ‡∏Ç‡∏≠‡∏á list ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
    res.status(201).json(newList); // 201 Created

  } catch (err) {
    console.error("Error creating list:", err.message);
    res.status(500).json({ error: 'Failed to create list' });
  }
};

// 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á Card ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô List
exports.createCard = async (req, res) => {
  try {
    // ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ listId ‡∏à‡∏≤‡∏Å URL ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è
    const { listId } = req.params; 
    const { description } = req.body;

    if (!description) {
      return res.status(400).json({ error: 'Description is required' });
    }

    // ‡∏™‡πà‡∏á‡πÅ‡∏Ñ‡πà description ‡πÅ‡∏•‡∏∞ listId ‡πÑ‡∏õ‡πÉ‡∏´‡πâ Model ‡∏Å‡πá‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡πÅ‡∏•‡πâ‡∏ß
    const newCard = await subtaskModel.createCard(description, listId);

    res.status(201).json(newCard);

  } catch (err) {
    console.error("Error creating card:", err.message);
    res.status(500).json({ error: 'Failed to create card' });
  }
};

// 4. ‡∏¢‡πâ‡∏≤‡∏¢ Card ‡πÑ‡∏õ‡∏¢‡∏±‡∏á List ‡∏≠‡∏∑‡πà‡∏ô
exports.moveCard = async (req, res) => {
  try {
    const { cardId } = req.params;
    const { newListId } = req.body;
    await subtaskModel.moveCardToList(cardId, newListId);
    // ‡∏™‡πà‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ 200 OK ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏´‡πâ JavaScript (fetch)
    res.status(200).json({ message: 'Card moved successfully' });
  } catch (err) {
    console.error("Error moving card:", err.message);
    res.status(500).json({ error: 'Failed to move card' });
  }
};

// --- List Management ---
exports.updateList = async (req, res) => {
  try {
    const { listId } = req.params;
    const { title } = req.body;
    if (!title) return res.status(400).json({ error: 'Title is required' });
    await subtaskModel.updateListTitle(listId, title);
    res.status(200).json({ message: 'List updated successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to update list' });
  }
};

exports.deleteList = async (req, res) => {
  try {
    const { listId } = req.params;
    await subtaskModel.deleteList(listId);
    res.status(200).json({ message: 'List deleted successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to delete list' });
  }
};

// --- Card Management ---
exports.updateCard = async (req, res) => {
  try {
    const { cardId } = req.params;
    const { description } = req.body;
    if (!description) return res.status(400).json({ error: 'Description is required' });
    await subtaskModel.updateCardDescription(cardId, description);
    res.status(200).json({ message: 'Card updated successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to update card' });
  }
};

exports.deleteCard = async (req, res) => {
  try {
    const { cardId } = req.params;
    await subtaskModel.deleteCard(cardId);
    res.status(200).json({ message: 'Card deleted successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to delete card' });
  }
};

exports.getCardDetails = async (req, res) => {
  try {
    const { cardId } = req.params;
    const card = await subtaskModel.getCardById(cardId);
    if (!card) {
      return res.status(404).json({ error: 'Card not found' });
    }
    res.status(200).json(card);
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch card details' });
  }
};

exports.reorderLists = async (req, res) => {
  try {
    const { listIds } = req.body; // ‡∏£‡∏±‡∏ö Array ‡∏Ç‡∏≠‡∏á list IDs ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß
    if (!listIds || !Array.isArray(listIds)) {
      return res.status(400).json({ error: 'Invalid data format' });
    }
    await subtaskModel.updateListOrder(listIds);
    res.status(200).json({ message: 'List order updated successfully' });
  } catch (err) {
    console.error("Error reordering lists:", err.message);
    res.status(500).json({ error: 'Failed to reorder lists' });
  }
};

exports.toggleCardStatus = async (req, res) => {
  try {
    const { cardId } = req.params;
    await subtaskModel.toggleCardStatus(cardId);
    // ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• card ‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ is_done ‡πÉ‡∏´‡∏°‡πà)
    const updatedCard = await subtaskModel.getCardById(cardId);
    res.status(200).json(updatedCard);
  } catch (err) {
    res.status(500).json({ error: 'Failed to toggle card status' });
  }
};

exports.completeList = async (req, res) => {
  try {
    const { listId } = req.params;
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡πà‡∏≤‡∏°‡∏µ card ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏´‡∏°
    const remainingCards = await subtaskModel.getRemainingCardsInList(listId);
    if (remainingCards.length > 0) {
      return res.status(400).json({ error: 'Cannot complete list: some cards are still remaining.' });
    }
    await subtaskModel.completeList(listId);
    res.status(200).json({ message: 'List completed successfully' });
  } catch (err) {
    res.status(500).json({ error: 'Failed to complete list' });
  }
};

exports.completeTask = async (req, res) => {
  try {
    const { taskId } = req.params;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ù‡∏±‡πà‡∏á‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ß‡πà‡∏≤‡∏°‡∏µ list ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const remainingLists = await subtaskModel.getRemainingListsInTask(taskId);
    if (remainingLists.length > 0) {
      return res.status(400).json({ error: 'Cannot complete task: some lists are still remaining.' });
    }

    await taskModel.completeTask(taskId);
    res.status(200).json({ message: 'Task completed successfully' });

  } catch (err) {
    console.error("Error completing task:", err.message);
    res.status(500).json({ error: 'Failed to complete task' });
  }
};

exports.showRecoverConfirm = async (req, res) => {
  try {
    const task = await taskModel.getTaskById(req.params.id, true); // `true` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏î‡∏∂‡∏á task ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ
    if (!task) return res.status(404).send('Task not found');
    res.render('pop-up/confirmRecover', { task });
  } catch (err) {
    res.status(500).send('Server Error');
  }
};

exports.showDeleteConfirm = async (req, res) => {
  try {
    const task = await taskModel.getTaskById(req.params.id, true);
    if (!task) return res.status(404).send('Task not found');
    res.render('pop-up/confirmDelete', { task });
  } catch (err) {
    res.status(500).send('Server Error');
  }
};
